<!DOCTYPE html>
<html>

<head>
  <title>Ingress Model Sandbox - Inventory viewer</title>
  <script src="../node_modules/gl-matrix/dist/gl-matrix.js"></script>
  <script src="../dist/ingress-model-viewer.js"></script>
  <script src="https://cdn.rawgit.com/eligrey/FileSaver.js/5733e40e5af936eb3f48554cf6a8a7075d71d18a/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.3/vue.js"></script>
  <style>
    html,
    body {
      height: 100%;
      width: 100%;
      position: relative;
      margin: 0;
    }

    #app1{
      width: 300px;
    }

    #app1 fieldset{
      min-width:150px;
      vertical-align: top;
    }

    #app1 fieldset label {
      display: inline-block;
      min-width:80px;
      text-align:right;
    }
  </style>
</head>

<body>
  <form id="app1">
    <fieldset>
      <legend>Camera</legend>
      <label>Distance:</label>
      <input type="range" max="5" min="1" step="0.2" v-model="distance" />
      <br/>
      <label>Angle:</label>
      <input type="range" max="90" min="-90" v-model="angle" />
      <br/>
      <label>Rotation:</label>
      <input type="range" min="0" max="360" v-model="rotation" /> {{rotation}}
      <br/>
      <input type="checkbox" id="id_save" v-model="save" />
      <label for="id_save">Save when clicking inventory</label>
      <br/>
    </fieldset>
    <fieldset>
      <legend>Inventory</legend>
      <ul style="list-style-type: none; padding: 0; height: 380px; overflow: scroll;">
        <li v-for="itemName in inventoryOptions">
          <a href="" v-on:click.prevent="changeInventory(itemName)">
            {{itemName}}
          </a>
        </li>
      </ul>
    </fieldset>
  </form>
  <div id="container" style="position: absolute; left: 300px; top: 0px; overflow: scroll; background: black">
    <canvas id="screen" height="2048" width="2048"></canvas>
  </div>
  <script type="text/javascript">
    var app1 = new Vue({
      el: "#app1",
      data: {
        distance: 2,
        angle: 30,
        rotation: 30,
        save: false,
        inventoryOptions: Object.keys(IMV.Entities.Inventory),
        inventory: "XMP Burster L8",
        saveFrame: 0
      },
      methods: {
        changeInventory: function (itemName) {
          this.clear();
          this.inventory = itemName;
          var item = IMV.Entities.Inventory[itemName];
          this.rotation = item.rotation || 30;
          new item(engine);

          if (this.save)
            this.saveFrame = 5;
        },
        clear: function () {
          var drawablesLength = engine.objectRenderer.drawables.length;
          for (var i = 0; i < drawablesLength; i++) {
            engine.objectRenderer.removeDrawable(engine.objectRenderer.drawables[0]);
          }
        }
      }
    });

    var canvas = document.getElementById('screen'),
      container = document.getElementById('container'),
      engine, assets = {};
    container.style.width = (window.innerWidth - 300 - 15) + 'px';
    container.style.height = (window.innerHeight - 15) + 'px';

    //window.addEventListener('resize', function () {
    //  engine.resize();
    //});

    function saveImageFromCanvas(canvas) {
      // Inspired by: https://stackoverflow.com/a/22267731/177663
      var ctx = canvas.getContext('webgl');
      var w = ctx.drawingBufferWidth,
        h = ctx.drawingBufferHeight,
        x, y, index;
      var minX = w, maxX = 0;
      var minY = h, maxY = 0;
      var pixels = new Uint8Array(w * h * 4);
      ctx.readPixels(0, 0, w, h, ctx.RGBA, ctx.UNSIGNED_BYTE, pixels);

      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          // Get the ALPHA channel value
          index = (y * w + x) * 4 + 3;
          if (pixels[index] > 0) {
            if (minX > x)
              minX = x;
            if (maxX < x)
              maxX = x;
            if (minY > y)
              minY = y;
            if (maxY < y)
              maxY = y;
          }
        }
      }

      w = maxX - minX + 1;
      h = maxY - minY + 1;

      var tmpCanvas = document.createElement('canvas');
      tmpCanvas.width = w;
      tmpCanvas.height = h;
      tmpCtx = tmpCanvas.getContext('2d');

      var crop = tmpCtx.createImageData(w, h);
      pixels = new Uint8Array(w * h * 4);
      ctx.readPixels(minX, minY, w, h, ctx.RGBA, ctx.UNSIGNED_BYTE, pixels);

      // We need to perform the conversion from Uint8Array to Uint8ClampedArray...
      // Whaaaaat, why is the image upside down?! Let's flip it while we copy everything.
      for (y = 0; y < h; y++) {
        var offset1 = y * w * 4;
        var offset2 = (h - y) * w * 4;
        for (x = 0; x < w * 4; x++) {
          crop.data[offset1 + x] = pixels[offset2 + x];
        }
      }

      tmpCtx.putImageData(crop, 0, 0);
      tmpCanvas.toBlob(function (blob) {
        saveAs(blob, app1.inventory + '.png');
      });
    }
    var updateCamera = function () {
      var x = app1.distance * Math.cos(app1.angle * Math.PI / 180) * Math.sin(app1.rotation / times);
      var y = app1.distance * Math.cos(app1.angle * Math.PI / 180) * Math.cos(app1.rotation / times);
      var height = app1.distance * Math.sin(app1.angle * Math.PI / 180);

      engine.camera.setFar(500).setPosition([x, height, y]).lookAt([0.0, 0.0, 0.0]);

      engine.updateView();

      if (app1.saveFrame === 1) {
        saveImageFromCanvas(canvas);
      }
      if (app1.saveFrame > 0)
        app1.saveFrame--;

      window.requestAnimationFrame(updateCamera);
    };

    var init = function (assets) {
      engine = new IMV.Engine(canvas, assets, true);
      controls = new IMV.Controls.Orbit(canvas, engine.camera, 100, {
        distanceMin: 1,
        distanceMax: 150
      });
      engine.preload().then(function () {
        console.log('ready');
        setupScene();
      }).catch(function (err) {
        console.error(err);
      });
    };

    var setupScene = function () {
      engine.camera.setFar(500).setPosition([0.0, 30, 20]).lookAt([0.0, 0.0, 0.0]);
      engine.updateView();
      engine.render();
      window.requestAnimationFrame(updateCamera);

      var item = new IMV.Entities.Inventory[app1.inventory](engine);
    };

    var times = 180/Math.PI;

    IMV.AssetLoader.loadResource('/manifest/assets.json', 'text').then(function (val) {
      assets = JSON.parse(val);
      if (assets) {
        if (IMV.Entities.Inventory['MUFG Capsule']) {
          // File does not exist in Ingress 1.128.0 and older versions
          delete assets.mesh["InterestCapsuleXmMesh"];
        }
        init(assets);
      }
    });

  </script>
</body>

</html>
